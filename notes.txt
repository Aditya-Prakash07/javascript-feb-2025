Hoisting in JavaScript (Short & Crisp) ğŸš€
Hoisting is JavaScriptâ€™s behavior of moving variable and function declarations to the top of their scope during compilation.

Key Points:
âœ… var is hoisted with undefined, but let and const stay in a Temporal Dead Zone (TDZ) and throw a ReferenceError if accessed before declaration.
âœ… Function declarations are fully hoisted, so they can be used before they appear in the code.
âœ… Function expressions & arrow functions are NOT hoisted (only the variable is hoisted, but not the function itself).

Example:
console.log(a); // undefined
var a = 10;

greet(); // "Hello!"
function greet() { console.log("Hello!"); }

console.log(b); // ReferenceError
let b = 20;
Best Practices:
ğŸ”¹ Use let and const instead of var.
ğŸ”¹ Declare functions before calling them.
ğŸ”¹ Avoid relying on hoisting for cleaner, bug-free code.






Temporal Dead Zone (TDZ) in JavaScript ğŸš€
The Temporal Dead Zone (TDZ) is the time between when a variable is hoisted and when it is initialized. Variables declared with let and const are hoisted but stay in the TDZ, meaning they cannot be accessed before their declaration.

Example:
console.log(a); // âŒ ReferenceError: Cannot access 'a' before initialization
let a = 10;
Key Points:
âœ… Applies to let and const (not var).
âœ… Prevents accessing variables before declaration.
âœ… Ends when the variable is initialized.

Best Practice:
ğŸ”¹ Always declare variables before using them to avoid TDZ errors.




Spread Operator (...) in JavaScript ğŸš€
The spread operator (...) is used to expand elements of an iterable (like arrays, objects, or strings) into individual elements.

Usage Examples:
âœ… Copying an Array:

const arr1 = [1, 2, 3];
const arr2 = [...arr1]; // Copy of arr1
console.log(arr2); // [1, 2, 3]
âœ… Merging Arrays:

const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4]
âœ… Spreading in Objects (Shallow Copy):

const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };
console.log(obj2); // { a: 1, b: 2, c: 3 }
âœ… Passing Arguments to Functions:

function sum(a, b, c) {
  return a + b + c;
}
const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6
Similar Operators:
ğŸ”¹ Rest Operator (...) â€“ Collects multiple values into an array (opposite of spread).

function sum(...nums) {
  return nums.reduce((a, b) => a + b);
}
console.log(sum(1, 2, 3)); // 6
ğŸ”¹ Destructuring with Spread:

const [first, ...rest] = [1, 2, 3, 4];
console.log(first); // 1
console.log(rest);  // [2, 3, 4]
Key Differences:
Operator	Purpose
Spread (...)	Expands an array/object into individual elements
Rest (...)	Gathers multiple values into an array
Best Practice: Use spread for copying, merging, and passing arguments, and rest for handling variable arguments.





Pass by Value vs. Pass by Reference in JavaScript ğŸš€
In JavaScript, primitives are passed by value, while objects are passed by reference.

ğŸ”¹ Pass by Value (Primitive Types)
When you pass primitive data types (number, string, boolean, null, undefined, symbol, bigint), a copy of the value is passed, meaning changes inside a function do not affect the original variable.

âœ… Example:

let a = 10;
function modify(x) {
    x = 20;
}
modify(a);
console.log(a); // 10 (original value remains unchanged)
ğŸ”¹ Why? Because a is a primitive, and only a copy of a is modified inside the function.

ğŸ”¹ Pass by Reference (Objects & Arrays)
When you pass objects (including arrays and functions), a reference to the original object is passed. This means changes inside a function do affect the original object.

âœ… Example:

let obj = { name: "Aditya" };
function modify(o) {
    o.name = "Rahul"; // Modifies the original object
}
modify(obj);
console.log(obj.name); // "Rahul" (original object is changed)
ğŸ”¹ Why? Because obj is an object, and the function modifies the original reference.

ğŸ”¹ How to Prevent Modification?
To avoid accidental changes, pass a copy of the object:

let obj = { name: "Aditya" };
function modify(o) {
    o = { ...o, name: "Rahul" }; // Creates a new object instead of modifying the original
}
modify(obj);
console.log(obj.name); // "Aditya" (original remains unchanged)
ğŸ”¹ Summary
Data Type	Passed By	Changes Affect Original?
Primitive (Number, String, Boolean, etc.)	Value	âŒ No
Objects, Arrays, Functions	Reference	âœ… Yes
Best Practice: Be careful when modifying objects inside functionsâ€”use spread ({...obj}) or Object.assign() to create copies when needed. ğŸš€




Shallow Copy vs. Deep Copy in JavaScript ğŸš€
ğŸ”¹ Shallow Copy:
A shallow copy creates a new object, but nested objects (references) are still shared with the original object.

âœ… Example (Shallow Copy using Spread ...)

let obj1 = { name: "Aditya", address: { city: "Hajipur" } };
let obj2 = { ...obj1 }; // Shallow copy

obj2.address.city = "Patna"; // Modifies original object too!

console.log(obj1.address.city); // "Patna" (changes reflect in original)
âš  Problem: Changing obj2.address.city also changes obj1.address.city because address is a reference.

ğŸ”¹ Deep Copy:
A deep copy creates a completely new object, including nested objects, breaking references to the original.

âœ… Example (Deep Copy using structuredClone)

let obj1 = { name: "Aditya", address: { city: "Hajipur" } };
let obj2 = structuredClone(obj1); // Deep copy

obj2.address.city = "Patna"; // Only obj2 is modified

console.log(obj1.address.city); // "Hajipur" (original remains unchanged)
ğŸ”¹ Key Differences
Feature	Shallow Copy	Deep Copy
Nested Objects	Shared (reference)	Completely copied
Modifying Copy Affects Original?	âœ… Yes	âŒ No
Methods	Object.assign(), ...spread	structuredClone(), JSON.parse(JSON.stringify(obj)), Lodash cloneDeep()
âœ… Use deep copy when modifying nested data to avoid unintended changes. ğŸš€